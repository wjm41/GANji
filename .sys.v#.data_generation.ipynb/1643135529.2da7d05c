{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Imports"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "\n",
    "import os\n",
    "import shutil\n",
    "\n",
    "import random\n",
    "import re\n",
    "import glob\n",
    "from PIL import Image,ImageDraw,ImageFont\n",
    "\n",
    "import ENVCONFIG"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load annotated font .csv and define root directory containing google fonts repo"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = pd.read_csv('google-fonts-annotation.csv')\n",
    "\n",
    "# change your path here\n",
    "rds_dir = ENVCONFIG.rds_dir\n",
    "ROOT = rds_dir+'/fonts/ofl'"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "define font filtering & retrieval function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "def filter_fonts_get_paths(df, root='./', variants=['_'], subsets=['_'], category=''):\n",
    "    # exceptions\n",
    "    if not variants or variants == [''] or variants == '': variants = ['_']\n",
    "    if not subsets or subsets == [''] or subsets == '': subsets = ['_']\n",
    "    # apply filters\n",
    "    regex_filters = variants + subsets + ['_'+category]\n",
    "    df_new = pd.concat([df.filter(regex=re.compile(regex, re.IGNORECASE), axis=1).sum(axis=1).astype(bool) for regex in regex_filters], axis=1)\n",
    "    mask = df_new.all(axis=1)\n",
    "    filtered_fontnames = list(df.loc[mask].family)\n",
    "    # construct file paths\n",
    "    paths = []\n",
    "    for fontname in filtered_fontnames:\n",
    "        if variants == ['_']: # select all variants\n",
    "            sel = glob.glob(f'{root}/{fontname.lower()}/**/**/**/*.ttf', recursive=True)\n",
    "            paths.extend(sel)\n",
    "        else:\n",
    "            for variant in variants:\n",
    "                sel = glob.glob(f'{root}/{fontname.lower()}/**/**/{fontname}-{variant}.ttf', recursive=True) \n",
    "                for path in sel:\n",
    "                    paths.append(path)\n",
    "    print(f'Found {len(paths)} font files.')\n",
    "    return paths"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Create data for list of characters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Found 90 font files.\n"
     ]
    },
    {
     "ename": "NameError",
     "evalue": "name 'shutil' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m/tmp/ipykernel_694/28131441.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     10\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mtext\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mcharacters\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     11\u001b[0m     \u001b[0mcharacterfolder\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mos\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpath\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mjoin\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'data'\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mtext\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 12\u001b[0;31m     \u001b[0mshutil\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrmtree\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcharacterfolder\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     13\u001b[0m     \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     14\u001b[0m         \u001b[0mos\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmkdir\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcharacterfolder\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mNameError\u001b[0m: name 'shutil' is not defined"
     ]
    }
   ],
   "source": [
    "characters=[\"福\"]\n",
    "#characters=[\"福\",\"新\",\"年\",\"快\",\"樂\",\"身\",\"體\",\"健\",\"康\",\"心\",\"想\",\"事\",\"成\"]\n",
    "IMG_WIDTH = 300\n",
    "IMG_HEIGHT = 300\n",
    "text_size = 150\n",
    "\n",
    "maxplotstoshow=1\n",
    "\n",
    "paths = filter_fonts_get_paths(df, root=ROOT, subsets=['japanese'], variants=['_'], category='')\n",
    "for text in characters:\n",
    "    characterfolder=os.path.join('data',text)\n",
    "    shutil.rmtree(characterfolder)\n",
    "    try:\n",
    "        os.mkdir(characterfolder)\n",
    "    except:\n",
    "        pass\n",
    "    \n",
    "    \n",
    "    for r in range(len(paths)):\n",
    "        # sample text and font\n",
    "\n",
    "\n",
    "        font = ImageFont.truetype(paths[r], text_size)\n",
    "\n",
    "        # # get text info (not being used but may be useful)\n",
    "        text_width, text_height = font.getsize(text)\n",
    "        left, top, right, bottom = font.getbbox(text)\n",
    "        print('text w & h: ', text_width, text_height)\n",
    "        print(left, top, right, bottom)\n",
    "\n",
    "\n",
    "\n",
    "        x = (right-left) # we can adjust this according to IMG_WIDTH etc\n",
    "        y = 150+(bottom-top)/2\n",
    "\n",
    "        # create a blank canvas with extra space between lines\n",
    "        canvas = Image.new('RGB', (IMG_WIDTH, IMG_HEIGHT), \"red\")\n",
    "\n",
    "        # draw the text onto the text canvas\n",
    "        draw = ImageDraw.Draw(canvas)\n",
    "        draw.text((x, y), text, 'black', font, anchor='ms')\n",
    "\n",
    "        fig = plt.figure(figsize=(10,10))\n",
    "        plt.imshow(canvas, aspect='auto')\n",
    "        plt.axis('off')\n",
    "        \n",
    "        filename = os.path.join(characterfolder,f'example{r}.jpg')\n",
    "        plt.savefig(filename)\n",
    "        # plt.imsave(filename, canvas, cmap='gray')\n",
    "        # plt.imsave(filename, canvas)\n",
    "        if r>maxplotstoshow:\n",
    "            plt.close()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "interpreter": {
   "hash": "7367a18b348ca6007dd30e14cd00de3b4d55612a2acbb3a217e58adb00f48737"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
